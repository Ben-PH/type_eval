use core::fmt;
use std::{env, fs::File, io::Write, path::Path};

use bitvec::{order::Lsb0, vec::BitVec};
const HIGHEST: u64 = 1024;
fn uints() -> impl Iterator<Item = u64> {
    // Use hardcoded values to avoid issues with cross-compilation.
    // See https://github.com/paholg/typenum/issues/162
    let first2: u32 = 11; // (highest as f64).log(2.0).round() as u32 + 1;
    let first10: u32 = 4; // (highest as f64).log(10.0) as u32 + 1;
    (0..(HIGHEST + 1))
        .chain((first2..64).map(|i| 2u64.pow(i)))
        .chain((first10..20).map(|i| 10u64.pow(i)))
}

pub enum UIntCode {
    U0,
    U1,
    ZeroBit(Box<UIntCode>),
    OneBit(Box<UIntCode>),
}

impl fmt::Display for UIntCode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            UIntCode::ZeroBit(ref bits) => write!(f, "UInt<{}, B0>", bits),
            UIntCode::OneBit(ref bits) => write!(f, "UInt<{}, B1>", bits),
            UIntCode::U0 => write!(f,"B0"),
            UIntCode::U1 => write!(f,"B1"),
        }
    }
}

// impl fmt::Display for IntCode {
//     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
//         match *self {
//             IntCode::Zero => write!(f, "Z0"),
//             IntCode::Pos(ref inner) => write!(f, "PInt<{}>", inner),
//             IntCode::Neg(ref inner) => write!(f, "NInt<{}>", inner),
//         }
//     }
// }
//

pub fn gen_uint(u: u64) -> UIntCode {
    let bits: BitVec<u64, Lsb0> = BitVec::from_element(u);
    let mut bits = bits.into_iter().take(64 - u.leading_zeros() as usize).rev();
    if bits.next().is_none() {
        return UIntCode::U0;
    }
    let mut current = UIntCode::U1;
    for is_bit in bits {
        current = if is_bit {
            UIntCode::OneBit(Box::new(current))
        } else {
            UIntCode::ZeroBit(Box::new(current))
        };
    }
    current
}


fn main() {
    println!("cargo:rerun-if-changed=build/main.rs"); // Allow caching the generation if `src/*` files change.

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest = Path::new(&out_dir).join("consts.rs");

    let mut f = File::create(&dest).unwrap();


    // Header stuff here!
    write!(
        f,
        "
/**
Type aliases for many constants.

This file is generated by typenum's build script.

For unsigned integers, the format is `U` followed by the number. We define aliases for

- Numbers 0 through {highest}
- Powers of 2 below `u64::MAX`
- Powers of 10 below `u64::MAX`

These alias definitions look like this:

```rust
use typenum::{{B0, B1, UInt, UTerm}};

# #[allow(dead_code)]
type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;
```

For positive signed integers, the format is `P` followed by the number and for negative
signed integers it is `N` followed by the number. For the signed integer zero, we use
`Z0`. We define aliases for

- Numbers -{highest} through {highest}
- Powers of 2 between `i64::MIN` and `i64::MAX`
- Powers of 10 between `i64::MIN` and `i64::MAX`

These alias definitions look like this:

```rust
use typenum::{{B0, B1, UInt, UTerm, PInt, NInt}};

# #[allow(dead_code)]
type P6 = PInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
# #[allow(dead_code)]
type N6 = NInt<UInt<UInt<UInt<UTerm, B1>, B1>, B0>>;
```

# Example
```rust
# #[allow(unused_imports)]
use typenum::{{U0, U1, U2, U3, U4, U5, U6}};
# #[allow(unused_imports)]
use typenum::{{N3, N2, N1, Z0, P1, P2, P3}};
# #[allow(unused_imports)]
use typenum::{{U774, N17, N10000, P1024, P4096}};
```

We also define the aliases `False` and `True` for `B0` and `B1`, respectively.
*/
#[allow(missing_docs)]
pub mod consts {{
    use crate::val_types::{{B1, B0, UInt}};


    pub type True = B1;
    pub type False = B0;
",
        highest = HIGHEST,
    )
    .unwrap();

    for u in uints() {
        writeln!(f, "    pub type U{} = {};", u, gen_uint(u)).unwrap();
    }
    write!(f, "}}").unwrap();

    // tests::build_tests().unwrap();

    // op::write_op_macro().unwrap();

    // #[cfg(feature = "const-generics")]
    // generic_const_mappings::emit_impls().unwrap();
}

// pub fn main() -> std::io::Result<()> {
//     let out_dir = std::env::var("OUT_DIR").unwrap();
//     let dest = std::path::Path::new(&out_dir).join("generic_const_mappings.rs");
//     let mut f = std::fs::File::create(&dest).unwrap();
//
//     #[allow(clippy::write_literal)]
//     write!(f, "{}", "\
// #[cfg(doc)]
// use generic_const_mappings::*;
//
// /// Module with some `const`-generics-friendly definitions, to help bridge the gap
// /// between those and `typenum` types.
// ///
// ///   - It requires the `const-generics` crate feature to be enabled.
// ///
// /// The main type to use here is [`U`], although [`Const`] and [`ToUInt`] may be needed
// /// in a generic context.
// #[allow(warnings)] // script-generated code
// #[cfg(feature = \"const-generics\")] // hints at doc_auto_cfg
// pub mod generic_const_mappings {
//     use crate::*;
//
//     /// The main mapping from a generic `const: usize` to a [`UInt`]: [`U<N>`] is expected to work like [`UN`].
//     ///
//     ///   - It requires the `const-generics` crate feature to be enabled.
//     ///
//     /// [`U<N>`]: `U`
//     /// [`UN`]: `U42`
//     ///
//     /// # Example
//     ///
//     /// ```rust
//     /// use typenum::*;
//     ///
//     /// assert_type_eq!(U<42>, U42);
//     /// ```
//     ///
//     /// This can even be used in a generic `const N: usize` context, provided the
//     /// genericity is guarded by a `where` clause:
//     ///
//     /// ```rust
//     /// use typenum::*;
//     ///
//     /// struct MyStruct<const N: usize>;
//     ///
//     /// trait MyTrait { type AssocType; }
//     ///
//     /// impl<const N: usize> MyTrait
//     ///     for MyStruct<N>
//     /// where
//     ///     Const<N> : ToUInt,
//     /// {
//     ///     type AssocType = U<N>;
//     /// }
//     ///
//     /// assert_type_eq!(<MyStruct<42> as MyTrait>::AssocType, U42);
//     /// ```
//     pub type U<const N: usize> = <Const<N> as ToUInt>::Output;
//
//     /// Used to allow the usage of [`U`] in a generic context.
//     pub struct Const<const N: usize>;
//
//     /// Used to allow the usage of [`U`] in a generic context.
//     pub trait ToUInt {
//         /// The [`UN`][`crate::U42`] type corresponding to `Self = Const<N>`.
//         type Output;
//     }
// \
//     ")?;
//
//     for uint in uints() {
//         write!(
//             f,
//             "
//     {cfg}
//     impl ToUInt for Const<{uint}> {{
//         type Output = U{uint};
//     }}
// \
//             ",
//             uint = uint,
//             cfg = feature_gate_to_64_bit(uint),
//         )?;
//     }
//     write!(f, "}}")?;
//     f.flush()?;
//     Ok(())
// }
//
// const fn feature_gate_to_64_bit(uint: u64) -> &'static str {
//     if uint > u32::MAX as u64 {
//         r#"#[cfg(target_pointer_width = "64")]"#
//     } else {
//         ""
//     }
// }
//
